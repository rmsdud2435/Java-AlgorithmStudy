package com.algorithm.exam.naver.fintech;

public class Test {

}
문제 설명
대형 마트와 같은 상품 판매 회사는 물품을 외부 거래처로부터 구매하여 일정 마진을 더한 후 고객에게 판매합니다. 이때, 고객에게 상품을 판매하고 얻은 금액을 매출액이라 하고, 상품을 거래처로부터 구입할 때 지불한 금액을 매출원가라고 합니다. 매출원가를 구하는 방법에는 선입선출법, 후입선출법 2가지 방법이 있습니다. 선입선출법에서는 먼저 구매한 제품이 먼저 판매된다고 가정을 하는 반면, 후입선출법에서는 나중에 구매한 제품이 먼저 판매가 된다고 가정합니다. 상품 구입과 판매 기록이 주어졌을 때, 두 방법으로 각각 매출원가를 계산하여 비교하려고 합니다.

아래 표는 어느 마트의 상품 구입과 판매 기록을 나타냅니다. 상품의 종류는 1가지만 주어집니다.

활동	가격	수량
구입	300	6
구입	500	3
판매	1000	4
구입	600	2
판매	1200	1
위 표에 따르면 구입한 상품의 수는 총 11개, 판매한 상품의 수는 총 5개입니다.
선입선출법은 먼저 구매한 상품이 먼저 판매된다고 가정하기 때문에, 총판매수량 5는 모두 첫 번째 구입에서 가져온 상품을 판매한 것으로 가정합니다. 그렇기 때문에 매출원가는 1500원(= 300 x 5)입니다.
후입선출법은 나중에 구매한 상품이 먼저 판매된다고 가정하기 때문에, 첫 번째 판매에서 발생한 매출원가는 1800원(= 500 x 3 + 300 x 1)이고, 두 번째 판매에서 발생한 매출원가는 600원(= 600 x 1)입니다. 따라서 총매출원가는 2400원(= 1800 + 600)입니다.

참고로, 매출원가를 계산할 때 물품을 판매한 가격은 고려할 필요가 없습니다.

상품의 구입 또는 판매 활동과 그때 거래된 상품의 가격과 수량을 나타내는 문자열이 시간 순서대로 담긴 배열 record가 주어집니다. 선입선출법과 후입선출법을 따라 계산한 매출원가를 각각 a, b라고 할 때, [a, b] 형식으로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
처음 갖고 있는 상품의 수와 매출원가는 0입니다.
record의 길이는 1 이상 10,000 이하입니다.
record의 원소는 "활동 가격 수량" 형식의 문자열입니다.
활동은 알파벳 대문자 'P' 또는 'S'입니다.
'P'는 구매를, 'S'는 판매를 나타냅니다.
가격은 1 이상 1,000 이하인 자연수입니다.
수량은 1 이상 1,000 이하인 자연수입니다.
갖고 있는 상품의 수량보다 많은 양의 판매하는 경우는 주어지지 않습니다.
입출력 예
record	result
["P 300 6", "P 500 3", "S 1000 4", "P 600 2", "S 1200 1"]	[1500, 2400]
["P 300 6", "P 500 3", "S 1000 4", "P 600 1", "S 1200 2"]	[1800, 2700]
["P 100 4", "P 300 9", "S 1000 7", "P 1000 8", "S 700 7", "S 700 3"]	[7100, 10700]
입출력 예 설명
입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
총판매수량은 6개입니다. 선입선출법에 따르면 처음에 300원으로 구매한 상품 6개를 판매한 것으로 가정합니다. 따라서 총매출원가는 1800원(= 300 x 6)입니다. 후입선출법에 따르면 첫 번째 판매에서 매출원가 1800원(= 500 x 3 + 300 x 1)과 두 번째 판매에서 매출원가 900원(= 600 x 1 + 300 x 1)을 합하여 총매출원가는 2700원입니다. 따라서 [1800, 2700]을 return 합니다.

입출력 예 #3
선입선출법에 따르면 각 판매 별로 다음과 같이 매출원가를 계산할 수 있습니다.

첫 번째 판매의 매출원가: 100 x 4 + 300 x 3 = 1300원
두 번째 판매의 매출원가: 300 x 6 + 1000 x 1 = 2800원
세 번째 판매의 매출원가: 1000 x 3 = 3000원
합계: 7100원
후입선출법에 따르면 각 판매 별로 다음과 같이 매출원가를 계산할 수 있습니다.

첫 번째 판매의 매출원가: 300 x 7 = 2100원
두 번째 판매의 매출원가: 1000 x 7 = 7000원
세 번째 판매의 매출원가: 1000 x 1 + 300 x 2 = 1600원
합계: 10700원
따라서 [7100, 10700]을 return 합니다.
		

		
		import java.util.*;

		class Solution {
		    public int[] solution(String[] record) {
		        int[] answer = new int[2];
		        
		        Queue<Integer> fifo = new LinkedList<Integer>();
		        Stack<Integer> filo = new Stack<Integer>();
		        
		        int filoAnswer = 0;
		        int fifoAnswer = 0;
		        
		        for(String elements: record){
		            String[] element = elements.split(" ");
		            String activity = element[0];
		            int price = Integer.parseInt(element[1]);
		            int quantity = Integer.parseInt(element[2]);
		            
		            if("P".equals(activity)){
		                for(int i = 0; i < quantity; i++){
		                    fifo.add(price);
		                    filo.push(price);
		                }
		            }else if("S".equals(activity)){
		                for(int i = 0; i < quantity; i++){
		                    filoAnswer += fifo.poll();
		                    fifoAnswer += filo.pop();
		                }
		            }
		        }
		        answer[0] = filoAnswer;
		        answer[1] = fifoAnswer;
		        return answer;
		    }
		}
		
		
		
		
		
		
		
		
		
		문제 설명
		주어진 배열 안에 A자 모양 부분 배열이 몇 개 있는지 알아보려고 합니다. 부분 배열은 어떤 배열 내부에 존재하는 또 다른 배열로, 원래 배열의 연속적인 부분입니다. 예를 들어 배열 [1, 2, 3]의 비어 있지 않은 부분 배열은 [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]으로, 6개가 있습니다.

		배열 arr이 다음과 같은 조건을 모두 만족할 경우 A자 모양이라고 합니다.

		arr의 길이 ≥ 3
		arr 내 어떤 인덱스 i가 다음과 같은 조건을 모두 만족합니다.
		arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
		arr[i] > arr[i + 1] > ... > arr의 마지막 원소
		0 < i < arr의 길이 - 1
		예를 들어 배열 [0, 1, 2, 5, 3, 7]의 부분 배열 [1, 2, 5, 3]은 1부터 5까지 줄곧 값이 증가하다가 5부터 마지막 원소까지 줄곧 값이 감소합니다. 따라서 부분 배열 [1, 2, 5, 3]은 A자 모양 배열입니다.

		배열 [0, 1, 2, 5, 3, 7]의 부분 배열 중 A자 모양 배열인 것은 [2, 5, 3], [1, 2, 5, 3], [0, 1, 2, 5, 3]으로, 3개가 있습니다.

		1차원 정수 배열 arr이 매개변수로 주어집니다. arr의 부분 배열 중 A자 모양 배열의 수를 return 하도록 solution 함수를 완성해주세요. 단, 결괏값이 매우 커질 수 있으므로 109 + 7로 나눈 나머지를 return 해주세요.

		제한사항
		3 ≤ arr의 길이 ≤ 100,000
		0 ≤ arr의 원소 ≤ 1,000,000,000
		입출력 예
		arr	result
		[0, 1, 2, 5, 3, 7]	3
		[1, 2, 3, 2, 1]	4
		[1, 2, 3, 2, 1, 4, 3, 2, 2, 1]	6
		[1, 2, 1, 2, 1]	2
		입출력 예 설명
		입출력 예 #1

		문제 예시와 같습니다.

		입출력 예 #2

		arr의 부분 배열 중 A자 모양 배열인 것은, [1, 2, 3, 2], [1, 2, 3, 2, 1], [2, 3, 2], [2, 3, 2, 1]로 4개가 있습니다. 따라서 4를 return 합니다.

		입출력 예 #3

		arr의 부분 배열 중 A자 모양 배열인 것은, [1, 2, 3, 2], [1, 2, 3, 2, 1], [2, 3, 2], [2, 3, 2, 1], [1, 4, 3], [1, 4, 3, 2]로 6개가 있습니다. 부분 배열 [1, 4, 3, 2, 2, 1]은 정점인 원소 4부터 마지막 원소 1까지 줄곧 값이 감소하지 않기 때문에 A자 모양 배열이 아닙니다. 따라서 6을 return 합니다.

		입출력 예 #4

		arr의 부분 배열 중 A자 모양 배열인 것은, 인덱스 0부터 2까지 [1, 2, 1] 배열과 인덱스 2부터 4까지 [1, 2, 1] 배열이 있습니다. 두 배열의 원소와 순서가 같더라도 위치가 다르므로 따로 세어야 합니다. 따라서 2를 return 합니다.
				
				
				class Solution {
		    public int solution(int[] arr) {
		        int answer = 0;
		        
		        int edgeStart = 0;
		        int edgeEnd = 0;
		        
		        if(arr[0]<arr[1]){
		            edgeStart++;
		        }
		        
		        for(int i = 1; i < arr.length-1; i++){
		            if(arr[i] <= arr[i+1] && arr[i-1]>arr[i]){
		                answer += edgeStart*edgeEnd;
		                edgeStart=0;
		                edgeEnd=0;
		            }
		            if(arr[i]<arr[i+1]){
		                edgeStart++;
		            }else if(arr[i]>arr[i+1]){
		                edgeEnd++;
		            }

		        }
		        
		        answer += edgeStart*edgeEnd;
		        
		        return answer;
		    }
		}
		
		
		
		
		
		문제 설명
		사회적 거리 유지를 위해 공연 관람객들의 좌석을 배정하려 합니다. 공연장의 각 좌석은 1 x 1 크기 정사각형 모양이며, 전체 좌석은 n x n 크기 정사각 격자 모양입니다. 관람객에게 좌석을 배정하는 규칙은 다음과 같습니다.

		제일 처음 입장하는 관람객은 1행 1열 좌석을 배정받습니다.
		두 번째 관람객부터는 먼저 좌석을 배정받은 다른 관람객 중 가장 가까운 관람객까지의 거리가 최대인 좌석을 배정합니다.
		만약 그런 좌석이 여러 개라면 열 번호가 가장 작은 좌석을 배정합니다.
		만약 열 번호가 가장 작은 좌석이 여러 개라면 행 번호가 가장 작은 좌석을 배정합니다.
		두 좌석 사이의 거리는 행 번호 차이 + 열 번호 차이입니다.
		예를 들어 [2행, 3열]과 [5행, 1열] 사이의 거리는 |2 - 5| + |3 - 1| = 5입니다(| |는 절댓값 기호입니다).
		다음은 5 x 5 크기 관람석에 좌석을 배정하는 예시입니다.

		seat_1.png

		제일 처음 입장하는 1번 관람객은 1행 1열에 배정합니다.
		2번 관람객은 1번 관람객까지의 거리가 최대인 5행 5열에 배정합니다.
		3번 관람객을 배정하기 위해 각 좌석에서 가장 가까운 관람객까지의 거리를 구하면 다음과 같습니다.
		seat_6.png

		이때, 가장 가까운 관람객까지의 거리가 최대인 좌석은 [5행 1열], [4행 2열], [3행 3열], [2행 4열], [1행 5열]입니다. 이중 열 번호가 가장 작은 [5행 1열]에 3번 관람객을 배정합니다.
		3번 관람객을 배정한 후 각 좌석에서 가장 가까운 관람객까지의 거리는 다음과 같습니다.
		seat_7.png

		3번 관람객을 배치한 후 [4행 2열]의 가장 가까운 관람객까지의 거리가 4 → 2로 변하며, 따라서 4번 관람객을 배치할 좌석은 [3행 3열]이 됩니다.
		아래 그림은 최대 수용 인원인 25명까지 관람객을 배치한 결과입니다.
		seat_2.png

		좌석의 크기 n, 관람객 수 k 가 매개변수로 주어질 때, k 번째 관람객이 배정받는 좌석의 위치를 return 하도록 solution 함수를 완성해주세요.

		제한사항
		n은 5 이상 50 이하인 자연수입니다.
		k는 1 이상 n2 이하인 자연수입니다.
		정답은 [행 번호, 열 번호] 형태로 return 해주세요.
		입출력 예
		n	k	result
		5	12	[4,4]
		5	16	[1,2]
		6	13	[4,5]
		입출력 예 설명
		입출력 예 #1

		seat_3.png

		입출력 예 #2

		seat_4.png

		입출력 예 #3

		seat_5.png
		
		
		
		
		class Solution {
		    public int[] solution(int n, int k) {
		        int[] answer = new int[2];
		        int peopleCount = 0;
		        int[] seat = new int[2];
		        
		        int[][] reservedSeats = new int[n*n][2];
		        peopleCount++;
		        reservedSeats[0][0]=0;
		        reservedSeats[0][1]=0;
		        
		        for(int i = 1; i < k ; i++){
		            int longestDistance = 0;
		            int longestDistanceX = 0;
		            int longestDistanceY = 0;
		            for(int y = 0; y < n; y++){
		                for(int x = 0; x < n; x++){
		                    int distance = getLeastDistance(x,y,peopleCount,reservedSeats,n);
		                    if(distance>longestDistance){
		                        longestDistance = distance;
		                        longestDistanceX = x;
		                        longestDistanceY = y;
		                    }
		                }
		            }
		            reservedSeats[i][0]=longestDistanceX;
		            reservedSeats[i][1]=longestDistanceY;
		            peopleCount++;
		        }
		        
		        answer[0] = reservedSeats[k-1][0]+1;
		        answer[1] = reservedSeats[k-1][1]+1;
		        return answer;
		    }
		    
		    public int getLeastDistance(int width, int heigt, int peopleCount, int[][] reservedSeats,int squareSize){
		        int leastDistance = Math.abs(width-reservedSeats[0][0])+ Math.abs(heigt-reservedSeats[0][1]);
		        for(int a = 1; a < peopleCount; a++){
		            int[] seat = reservedSeats[a];
		            int distance = Math.abs(width-seat[0])+ Math.abs(heigt-seat[1]);
		            if(leastDistance > distance){
		                leastDistance = distance;
		            }
		        }
		        return leastDistance;
		    }
		}
		
		
		
		
		문제 설명
		2차원 좌표 평면에 다양한 형태의 직사각형들이 놓여 있습니다. 모든 직사각형은 X축 위, Y축 오른쪽에 존재하며, 직사각형의 모든 변은 X축 또는 Y축에 평행합니다. 이 직사각형들을 아래 규칙에 따라 이동하려 합니다.

		먼저, 직사각형을 아래 방향으로 더 움직일 수 없을 때까지 이동시킵니다.
		이때, 각 직사각형은 Y축 방향으로만 이동하며, X축 방향으로는 이동할 수 없습니다.
		다음으로 직사각형을 왼쪽 방향으로 더 움직일 수 없을 때까지 이동시킵니다.
		이때, 각 직사각형은 X축 방향으로만 이동하며, Y축 방향으로는 이동할 수 없습니다.
		직사각형은 X축, 또는 Y축에 닿으면 더는 움직이지 않으며, 각 직사각형은 다른 직사각형을 뚫거나 통과해서 움직일 수 없습니다. 또, 모든 직사각형은 회전이나 기울임 없이 X축, Y축에 평행하게 움직여야 합니다.

		다음은 좌표평면 위에 놓인 직사각형이 움직이는 예시를 나타낸 그림입니다.

		rect_move_1.png

		먼저, 직사각형을 아래 방향으로 이동시키면 다음 그림과 같이 됩니다.

		rect_move_2.png

		다음으로, 직사각형을 왼쪽 방향으로 이동시키면 다음 그림과 같이 됩니다.

		rect_move_3.png

		위 그림이 모든 직사각형을 아래로 한 번, 왼쪽으로 한 번 이동시킨 최종 결과입니다. 위 예시에서 G번 직사각형의 경우 아래쪽 방향으로 더 움직일 수 있는 상태이나, 본 문제에서는 모든 직사각형을 아래로 한 번, 왼쪽으로 한 번만 이동시킨 결과를 구하면 됩니다.

		직사각형이 담긴 2차원 배열 rectangles가 매개변수로 주어질 때, 직사각형들을 문제에 주어진 조건대로 이동시킨 후 각 직사각형의 위치를 배열에 담아 return 하도록 solution 함수를 완성해주세요.

		제한사항
		rectangles의 세로(행) 길이는 1 이상 100,000 이하입니다.
		rectangles의 가로(열) 길이는 4 입니다.
		rectangles의 각 행은 [x1, y1, x2, y2] 형태입니다.
		x1, y1은 직사각형의 왼쪽 아래 꼭짓점의 x, y 좌표를 나타냅니다.
		x2, y2는 직사각형의 오른쪽 위 꼭짓점의 x, y 좌표를 나타냅니다.
		좌표값은 0 이상 1,000,000 이하인 정수입니다.
		직사각형의 한 변의 길이는 1 이상 20 이하입니다.
		직사각형이 겹쳐있는 등 잘못된 데이터는 입력으로 주어지지 않습니다.
		return하는 배열은 각 직사각형의 위치를 담은 문자열 배열입니다.
		각 직사각형의 최종 위치를 "x1 y1 x2 y2" 의 문자열 형태로 배열에 담아 return 해주세요
		x1, y1은 직사각형의 왼쪽 아래 꼭짓점의 x, y 좌표입니다.
		x2, y2는 직사각형의 오른쪽 위 꼭짓점의 x, y 좌표입니다.
		x1, y1, x2, y2는 공백(스페이스) 하나로 구분해 주세요.
		첫 번째 직사각형부터 순서대로 배열에 담으면 됩니다.
		입출력 예
		rectangles	result
		[[0,2,1,3],[1,2,2,5],[3,3,4,4],[4,1,6,3],[1,6,5,7],[5,5,7,6],[5,8,6,10]]	["0 0 1 1","1 0 2 3","2 0 3 1","3 0 5 2","0 3 4 4","2 2 4 3","4 3 5 5"]
		입출력 예 설명
		입출력 예 #1

		문제의 예시와 같습니다.
		
		
		
		
		